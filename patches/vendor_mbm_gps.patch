diff --git a/libmbm-gps/src/gpsctrl/atchannel.c b/libmbm-gps/src/gpsctrl/atchannel.c
index 81accd6..be88c55 100644
--- a/libmbm-gps/src/gpsctrl/atchannel.c
+++ b/libmbm-gps/src/gpsctrl/atchannel.c
@@ -652,7 +652,7 @@ static void *readerLoop(void *arg)
     set_at_context((struct atcontext *) arg);
     context = get_at_context();
 
-    MBMLOGV("Entering readerLoop()");
+    LOGI("Entering readerLoop()");
 
     for (;;) {
         const char * line;
@@ -686,7 +686,7 @@ static void *readerLoop(void *arg)
     }
 
     onReaderClosed();
-    MBMLOGV("Exiting readerLoop()");
+    LOGI("Exiting readerLoop()");
     return NULL;
 }
 
@@ -897,6 +897,7 @@ int at_reader_open(int fd, ATUnsolHandler h, int loglevel)
     pthread_attr_init (&attr);
     pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
 
+    LOGI("pthread_create readerLoop");
     ret = pthread_create(&context->tid_reader, &attr, readerLoop, context);
 
     if (ret < 0) {
@@ -923,11 +924,11 @@ void at_reader_close(void)
     ENTER;
 
     if (context->fd >= 0) {
-        MBMLOGV("%s, closing fd=%d", __FUNCTION__, context->fd);
+        LOGI("%s, closing at reader fd=%d", __FUNCTION__, context->fd);
         if (close(context->fd) != 0)
             MBMLOGE("%s, failed to close fd %d!", __FUNCTION__, context->fd);
     } else {
-        MBMLOGV("%s, fd already closed", __FUNCTION__);
+        LOGW("%s, fd already closed", __FUNCTION__);
         EXIT;
         return;
     }
@@ -943,6 +944,7 @@ void at_reader_close(void)
     pthread_mutex_unlock(&context->commandmutex);
 
     /* Kick readerloop. */
+    LOGI("kick readerLoop");
     write(context->readerCmdFds[1], "x", 1);
 
     EXIT;
diff --git a/libmbm-gps/src/gpsctrl/gps_ctrl.c b/libmbm-gps/src/gpsctrl/gps_ctrl.c
index 7353ac9..1bba8d4 100644
--- a/libmbm-gps/src/gpsctrl/gps_ctrl.c
+++ b/libmbm-gps/src/gpsctrl/gps_ctrl.c
@@ -140,6 +140,8 @@ static void *unsolicitedHandler(void *data)
 
     ENTER;
 
+    LOGI("unsolictedhandler enter");
+
     queued_event *event = (queued_event *)data;
     if (NULL == event)
         MBMLOGE("%s: event = NULL", __FUNCTION__);
@@ -151,6 +153,8 @@ static void *unsolicitedHandler(void *data)
         free(event);
     }
 
+    LOGI("unsolictedhandler exit");
+
     EXIT;
     return NULL;
 }
@@ -215,6 +219,7 @@ static void onUnsolicited(const char *s, const char *sms_pdu)
                 EXIT;
                 return;
             }
+  LOGI("enqueue_event");
             enqueue_event(unsolicitedHandler, (void *)event);
         }
     }
@@ -259,6 +264,7 @@ void enqueue_event (gpsctrl_queued_event queued_event, void *data)
 
     pthread_t event_thread;
 
+LOGI("pthread_create queued_event");
     ret = pthread_create(&event_thread, NULL, queued_event, data);
     if (ret < 0)
         MBMLOGE("%s error creating event thread", __FUNCTION__);
@@ -389,6 +395,7 @@ void gpsctrl_set_position_mode (int mode, int recurrence)
     } else
         context->interval = recurrence;
 
+    MBMLOGI("New GPS mode: %d Interval: %d", context->pref_mode, context->interval);
     EXIT;
 }
 
@@ -617,6 +624,7 @@ int gpsctrl_start(void)
     if (err < 0)
         return -1;
 
+    MBMLOGI("GPS Started in mode: %d", mode);
     return 0;
 }
 
@@ -660,9 +668,8 @@ int gpsctrl_stop(void)
 static void close_devices(void)
 {
 
-    at_reader_close();
-
     nmea_close();
+    at_reader_close();
 
 }
 
@@ -712,9 +719,10 @@ void gpsctrl_set_is_connected (int connected)
     ENTER;
 
     if (context->pref_mode == MODE_PGPS) {
-        if (gpsctrl_get_device_is_ready())
+        if (gpsctrl_get_device_is_ready()) {
+            MBMLOGI("Setting eedata state to: %d", connected);
             pgps_set_eedata(connected);
-        else
+        } else
             MBMLOGW("Not setting eedata since the device is not ready.");
     } else
         MBMLOGI("Not setting eedata since preferred mode is not PGPS");
diff --git a/libmbm-gps/src/gpsctrl/nmeachannel.c b/libmbm-gps/src/gpsctrl/nmeachannel.c
index 03768f8..8b536b7 100644
--- a/libmbm-gps/src/gpsctrl/nmeachannel.c
+++ b/libmbm-gps/src/gpsctrl/nmeachannel.c
@@ -166,11 +166,11 @@ void nmea_close (void)
     ENTER;
 
     if (context->nmea_fd >= 0) {
-        MBMLOGV("%s, closing fd=%d", __FUNCTION__, context->nmea_fd);
+        LOGI("%s, closing nmea fd=%d", __FUNCTION__, context->nmea_fd);
         if (close(context->nmea_fd) != 0)
             MBMLOGE("%s, failed to close fd %d!", __FUNCTION__, context->nmea_fd);
     } else {
-        MBMLOGV("%s, fd already closed", __FUNCTION__);
+        LOGW("%s, fd already closed", __FUNCTION__);
         EXIT;
         return;
     }
diff --git a/libmbm-gps/src/mbm_gps.c b/libmbm-gps/src/mbm_gps.c
index 0cb9de8..4684285 100644
--- a/libmbm-gps/src/mbm_gps.c
+++ b/libmbm-gps/src/mbm_gps.c
@@ -482,13 +482,13 @@ mbm_agpsril_update_network_state(int connected, int type, int roaming,
 
     ENTER;
 
-    if ((old_conn != connected) || (old_roam != roaming) || (old_type != type)) {
+//    if ((old_conn != connected) || (old_roam != roaming) || (old_type != type)) {
         MBMLOGI("connected=%i type=%i roaming=%i, extra_info=%s",
             connected, type, roaming, extra_info);
-        old_conn = connected;
-        old_roam = roaming;
-        old_type = type;
-    }
+//        old_conn = connected;
+//        old_roam = roaming;
+//        old_type = type;
+//    }
 
     context->ril_connected = connected;
     context->ril_roaming = roaming;
@@ -788,9 +788,11 @@ int open_at_channel(void)
 
     ret = wait_for_emrdy(at_fd, TIMEOUT_EMRDY);
 
-    if (ret == CLEANUP_REQUESTED)
+    if (ret == CLEANUP_REQUESTED) {
+        if (ret == -1)
+            close(at_fd);
         return CLEANUP_REQUESTED;
-    else if (ret == -1) {
+    } else if (ret == -1) {
         close(at_fd);
         return -1;
     } else
@@ -812,8 +814,7 @@ static void main_loop(void *arg)
     int ret;
     int at_fd;
     int nmea_fd = -1;
-    int at_channel_lost;
-    int nmea_channel_lost;
+    int any_channel_lost;
     int i, at_dev, nmea_dev;
     struct stat sb;
     (void) arg;
@@ -832,8 +833,7 @@ static void main_loop(void *arg)
     }
 
     while (1) {
-        at_channel_lost = 0;
-        nmea_channel_lost = 0;
+        any_channel_lost = 0;
         at_fd = open_at_channel();
         if (at_fd == CLEANUP_REQUESTED)
             goto exit;
@@ -877,7 +877,7 @@ static void main_loop(void *arg)
         epoll_register(epoll_fd, cmd_fd);
         epoll_register(epoll_fd, nmea_fd);
 
-        while (!nmea_channel_lost) {
+        while (!any_channel_lost) {
             struct epoll_event event[2];
             int nevents;
             nevents = epoll_wait(epoll_fd, event, 2, -1);
@@ -894,7 +894,8 @@ static void main_loop(void *arg)
                     MBMLOGE("EPOLLERR or EPOLLHUP after epoll_wait(%x)!", event[i].events);
                     if (event[i].data.fd == nmea_fd) {
                         MBMLOGW("NMEA channel lost. Will try to recover.");
-                        nmea_channel_lost = 1;
+                        any_channel_lost = 1;
+                        continue;
                     }
                 }
 
@@ -927,8 +928,9 @@ static void main_loop(void *arg)
                                                         __FUNCTION__);
                             at_reader_close();
                             gpsctrl_set_device_is_ready(0);
-                            at_channel_lost = 1;
+                            any_channel_lost = 1;
                             MBMLOGW("AT channel lost. Will try to recover");
+                            continue;
                             break;
                         case CMD_QUIT:
                             goto exit;
@@ -945,14 +947,15 @@ static void main_loop(void *arg)
                     MBMLOGE("epoll_wait() returned unkown event %x", event[i].events);
             }
         }
-
+LOGI("gpsctrl_set_device_is_ready0");
         gpsctrl_set_device_is_ready(0);
+LOGI("epoll_deregister");
         epoll_deregister(epoll_fd, cmd_fd);
         epoll_deregister(epoll_fd, nmea_fd);
-
+LOGI("gpsctrl_cleanup");
 retry:
         gpsctrl_cleanup();
-
+LOGI("status_callback");
         if (context->gps_status.status != GPS_STATUS_ENGINE_OFF) {
             context->gps_status.status = GPS_STATUS_ENGINE_OFF;
             context->status_callback(&context->gps_status);
@@ -963,14 +966,14 @@ retry:
            devices is being removed from filesystem */
         i = TIMEOUT_DEVICE_REMOVED;
         do {
+            sleep(1);
             at_dev = (0 == stat(ctrlcontext->at_dev, &sb));
             nmea_dev = (0 == stat(ctrlcontext->nmea_dev, &sb));
             if (at_dev || nmea_dev) {
-                MBMLOGD("Waiting for %s%s%s to be removed (%d)...",
+                LOGD("Waiting for %s%s%s to be removed (%d)...",
                     at_dev ? ctrlcontext->at_dev : "",
                     at_dev && nmea_dev ? " and ": "",
                     nmea_dev ? ctrlcontext->nmea_dev : "", i);
-                sleep(1);
                 i--;
             }
         } while ((at_dev || nmea_dev) && i);
@@ -1174,7 +1177,7 @@ static void mbm_gps_cleanup(void)
 
     context->gps_initiated = 0;
 
-    MBMLOGD("%s, waiting for main thread to exit", __FUNCTION__);
+LOGI("%s, waiting for main thread to exit", __FUNCTION__);
     pthread_mutex_lock(&context->cleanup_mutex);
 
     add_pending_command(CMD_QUIT);
@@ -1182,10 +1185,10 @@ static void mbm_gps_cleanup(void)
 
     pthread_cond_wait(&context->cleanup_cond, &context->cleanup_mutex);
 
-    MBMLOGD("%s, stopping service handler", __FUNCTION__);
+LOGI("%s, stopping service handler", __FUNCTION__);
     service_handler_stop();
 
-    MBMLOGD("%s, cleanup gps ctrl", __FUNCTION__);
+LOGI("%s, cleanup gps ctrl", __FUNCTION__);
     gpsctrl_cleanup();
 
     pthread_mutex_unlock(&context->cleanup_mutex);
@@ -1248,6 +1251,8 @@ static int mbm_gps_stop(void)
         err = gpsctrl_stop();
         if (err < 0)
             MBMLOGE("Error stopping gps");
+        else
+            MBMLOGI("GPS Stoppped");
     }
 
     context->gps_started = 0;
@@ -1370,7 +1375,7 @@ mbm_gps_set_position_mode(GpsPositionMode mode,
     (void) preferred_time;
     (void) *get_mode_name;
 
-    MBMLOGV("%s:enter  %s min_interval = %d recurrence=%d pref_time=%d",
+    MBMLOGI("%s:enter  %s min_interval = %d recurrence=%d pref_time=%d",
          __FUNCTION__, get_mode_name(mode), min_interval, recurrence,
          preferred_time);
 
diff --git a/libmbm-gps/src/mbm_service_handler.c b/libmbm-gps/src/mbm_service_handler.c
index 563c51f..c1af8e7 100644
--- a/libmbm-gps/src/mbm_service_handler.c
+++ b/libmbm-gps/src/mbm_service_handler.c
@@ -293,7 +293,8 @@ static void parse_message(char *msg)
             pgps_read_data(id, path);
         }
     } else {
-        MBMLOGD("%s, unknown message from mbm service received(%s)", __FUNCTION__, data);
+        MBMLOGD("%s, unknown message from mbm service received(%s)",
+                                             __FUNCTION__, msg);
     }
 
     free(data);
@@ -312,6 +313,8 @@ static void* socket_loop(void* arg)
 
     ENTER;
 
+LOGI("socket_loop() enter");
+
     if ((ret = internal_init()) < 0) {
         MBMLOGE("Error initializing socket");
         EXIT;
@@ -368,6 +371,7 @@ int service_handler_init(int loglevel)
         return -1;
     }
 
+LOGI("pthread_create socket_loop");
     ret = pthread_create(&socket_thread, NULL, socket_loop, NULL);
     if (ret < 0) {
         LOGE("%s error creating socket thread", __FUNCTION__);
@@ -383,6 +387,8 @@ int service_handler_stop(void)
 
     ENTER;
 
+LOGI("service_handler_stop sending QUIT");
+
     service_handler_send_message(CMD_SERVICE_QUIT, "");
     close(context->socket);
 
